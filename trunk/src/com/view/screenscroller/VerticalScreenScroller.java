package com.view.screenscroller;import com.view.screenscroller.VerticalScreenActivity.TopBottomListener;import android.content.Context;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.VelocityTracker;import android.view.View;import android.view.ViewConfiguration;import android.view.ViewGroup;import android.widget.Scroller;public class VerticalScreenScroller extends ViewGroup implements TopBottomListener {    public static boolean startTouch = true;    public boolean isScrollable = true;    private int mScreenHeight;    private boolean mIsTop = true, mIsBottom;    public boolean isScrollable() {        return isScrollable;    }    public void setScrollable(boolean isScrollable) {        this.isScrollable = isScrollable;    }    private Scroller mScroller;    /*     * 速度追踪器，主要是为了通过当前滑动速度判断当前滑动是否为fling     */    private VelocityTracker mVelocityTracker;    /*     * 记录当前屏幕下标，取值范围是：0 到 getChildCount()-1     */    private int mCurScreen;    private int mDefaultScreen = 0;    /**     * 初始化后默认显示的那个屏幕号     *      * @param defaultScreen     */    public void setDefaultScreen(int defaultScreen) {        this.mDefaultScreen = defaultScreen;    }    public void setCurScreen(int curScreen) {        mCurScreen = curScreen;    }    /*     * Touch状态值 0：静止 1：滑动     */    private static final int TOUCH_STATE_REST = 0;    private static final int TOUCH_STATE_SCROLLING = 1;    /*     * 记录当前touch事件状态--滑动（TOUCH_STATE_SCROLLING）、静止（TOUCH_STATE_REST 默认）     */    private int mTouchState = TOUCH_STATE_REST;    private static final int SNAP_VELOCITY = 300;    /*     * 记录touch事件中被认为是滑动事件前的最大可滑动距离     */    private int mTouchSlop;    /*     * 记录滑动时上次手指所处的位置     */    private float mLastMotionX;    private float mLastMotionY;    public VerticalScreenScroller(Context context, AttributeSet attrs) {        this(context, attrs, 0);    }    public VerticalScreenScroller(Context context, AttributeSet attrs, int defStyle) {        super(context, attrs, defStyle);        mScroller = new Scroller(context);        mCurScreen = mDefaultScreen;        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();        ((VerticalScreenActivity) context).setTopBottomListener(this);    }    @Override    protected void onLayout(boolean changed, int l, int t, int r, int b) {        int childTop = 0;        final int childCount = getChildCount();        for (int i = 0; i < childCount; i++) {            final View childView = getChildAt(i);            if (childView.getVisibility() != View.GONE) {                final int childWidth = childView.getMeasuredWidth();                final int childheight = childView.getMeasuredHeight();                childView.layout(0, childTop, childWidth,                        childTop + childheight);                childTop += childheight;            }        }        if (mNeedToResyncScreenEdgeOnLayout == true) {            scrollTo(0, mCurScreen * mScreenHeight);            mNeedToResyncScreenEdgeOnLayout = false;        }    }    @Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        super.onMeasure(widthMeasureSpec, heightMeasureSpec);        final int count = getChildCount();        for (int i = 0; i < count; i++) {            getChildAt(i).measure(widthMeasureSpec, heightMeasureSpec);        }        int height = MeasureSpec.getSize(heightMeasureSpec);        if (mScreenHeight != height) {            mScreenHeight = height;            mNeedToResyncScreenEdgeOnLayout = true;        }    }    /**     * 方法名称：snapToDestination 方法描述：根据当前位置滑动到相应界面     *      * @param whichScreen     */    public void snapToDestination() {        final int screenWidth = mScreenHeight;        final int destScreen = (getScrollY() + screenWidth / 2) / screenWidth;        snapToScreen(destScreen, true);    }    /**     * 方法名称：snapToScreen 方法描述：滑动到到第whichScreen（从0开始）个界面，有过渡效果     *      * @param whichScreen     */    public void snapToScreen(int whichScreen, boolean shouldAnimate) {        // get the valid layout page        whichScreen = Math.max(0, Math.min(whichScreen, getChildCount() - 1));        if (getScrollY() != (whichScreen * mScreenHeight)) {            final int delta = whichScreen * mScreenHeight - getScrollY();            int duration = 0;            if (shouldAnimate) {                duration = Math.min(320, (int) (Math.abs(delta) * 1.2));            }            mScroller.startScroll(0, getScrollY(), 0, delta, duration);            mCurScreen = whichScreen;            invalidate(); // Redraw the layout        }    }    private boolean mNeedToResyncScreenEdgeOnLayout = false;    /**     * 方法名称：setToScreen 方法描述：指定并跳转到第whichScreen（从0开始）个界面     *      * @param whichScreen     */    public void setToScreen(int whichScreen) {        whichScreen = Math.max(0, Math.min(whichScreen, getChildCount() - 1));        if (mScreenHeight != 0) {            // TODO: potential bug here, if view is not layed out, will not call            // doScrollAction            scrollTo(0, whichScreen * mScreenHeight);        } else {            mNeedToResyncScreenEdgeOnLayout = true;        }        mCurScreen = whichScreen;    }    public int getCurScreen() {        return mCurScreen;    }    @Override    public void computeScroll() {        if (mScroller.computeScrollOffset()) {            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());            postInvalidate();        }    }    @Override    public boolean onTouchEvent(MotionEvent event) {        if (!isScrollable) {            return super.onTouchEvent(event);        }        if (mVelocityTracker == null) {            mVelocityTracker = VelocityTracker.obtain();        }        mVelocityTracker.addMovement(event);        final int action = event.getAction();        final float y = event.getY();        switch (action) {            case MotionEvent.ACTION_DOWN:                if (!mScroller.isFinished()) {                    mScroller.abortAnimation();                }                mLastMotionY = y;                break;            case MotionEvent.ACTION_MOVE:                int deltaY = (int) (mLastMotionY - y);                mLastMotionY = y;                System.out.println("getScrollY onTouchEvent=" + getScrollY());                /*if (mIsBottom && getScrollY() < 0 || mIsTop && getScrollY() > 0) {                    return super.onTouchEvent(event);                }*/                if (deltaY >= 0) {                    // moving up                    if (getScrollY() >= mScreenHeight * (getChildCount() - 1)) {                        // do nothing on scroll to right edge                        scrollBy(0, deltaY);                    } else {                        int actualMovedValue = Math.min(deltaY,                                (mScreenHeight * (getChildCount() - 1)) - getScrollY());                        scrollBy(0, actualMovedValue);                    }                } else {                    // moving down                    if (getScrollY() <= 0) {                        // do nothing so won't scroll over the left edge                        scrollBy(0, deltaY);                    } else {                        int actualMovedValue = Math.min(-deltaY, getScrollY());                        scrollBy(0, -actualMovedValue);                    }                }                break;            case MotionEvent.ACTION_UP:            case MotionEvent.ACTION_CANCEL:                final VelocityTracker velocityTracker = mVelocityTracker;                velocityTracker.computeCurrentVelocity(1000);                int velocityY = (int) velocityTracker.getYVelocity();                if ((mIsTop && getScrollY() < 0) || (mIsBottom && getScrollY() > 0)) {                    if (mCurScreen > 0 && (velocityY > SNAP_VELOCITY)) {                        // Fling enough to move left                        snapToScreen(mCurScreen - 1, true);                    } else if (mCurScreen < getChildCount() - 1 && (velocityY < -SNAP_VELOCITY)) {                        // Fling enough to move right                        if (getScrollY() != 0) {                            snapToScreen(mCurScreen + 1, true);                        }                    } else {                        snapToDestination();                    }                    if (mVelocityTracker != null) {                        mVelocityTracker.recycle();                        mVelocityTracker = null;                    }                    mTouchState = TOUCH_STATE_REST;                    System.out.println("zhixing child  v=" + velocityY + "   mIsTop=" + mIsTop                            + "  mIsBottom=" + mIsBottom + "  action=" + action);                } else {                    System.out.println("zhixing child  v=" + velocityY + "   mIsTop=" + mIsTop                            + "  mIsBottom=" + mIsBottom + "  action=" + action);                    return super.onTouchEvent(event);                }                break;        }        return true;    }    @Override    public boolean onInterceptTouchEvent(MotionEvent ev) {        final int action = ev.getAction();        if ((action == MotionEvent.ACTION_MOVE) && (mTouchState != TOUCH_STATE_REST)) {            return true;        }        System.out.println("getScrollY onInterceptTouchEvent=" + getScrollY());        final float x = ev.getX();        final float y = ev.getY();        switch (action) {            case MotionEvent.ACTION_DOWN:                mLastMotionX = x;                mLastMotionY = y;                mTouchState = mScroller.isFinished() ? TOUCH_STATE_REST : TOUCH_STATE_SCROLLING;                break;            case MotionEvent.ACTION_MOVE:                if (!isScrollable) {                    return false;                }                /*if (mIsBottom && getScrollY() < 0 || mIsTop && getScrollY() > 0) {                    return super.onInterceptTouchEvent(ev);                }*/                int yDiff = (int) (mLastMotionY - y);                if (mIsBottom && yDiff < 0) {                    return false;                } else if (mIsTop && yDiff > 0) {                    return false;                }                yDiff = Math.abs(yDiff);                if (yDiff > mTouchSlop) {                    if (Math.abs(mLastMotionY - y) / Math.abs(mLastMotionX - x) > 1)                        mTouchState = TOUCH_STATE_SCROLLING;                }                break;            case MotionEvent.ACTION_CANCEL:            case MotionEvent.ACTION_UP:                mTouchState = TOUCH_STATE_REST;                break;        }        return mTouchState != TOUCH_STATE_REST;    }    @Override    public void setTop(boolean top) {        mIsTop = top;    }    @Override    public void setBottom(boolean bottom) {        mIsBottom = bottom;    }}