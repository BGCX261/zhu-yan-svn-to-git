package com.view.screenscroller;import android.content.Context;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.VelocityTracker;import android.view.View;import android.view.ViewConfiguration;import android.view.ViewGroup;import android.widget.Scroller;public class ScreenScroller extends ViewGroup {    public static boolean startTouch = true;    public boolean isScrollable = true;    private int mScreenWidth;    public boolean isScrollable() {        return isScrollable;    }    public void setScrollable(boolean isScrollable) {        this.isScrollable = isScrollable;    }    private Scroller mScroller;    /*     * 速度追踪器，主要是为了通过当前滑动速度判断当前滑动是否为fling     */    private VelocityTracker mVelocityTracker;    /*     * 记录当前屏幕下标，取值范围是：0 到 getChildCount()-1     */    private int mCurScreen;    private int mDefaultScreen = 0;    /**     * 初始化后默认显示的那个屏幕号     *      * @param defaultScreen     */    public void setDefaultScreen(int defaultScreen) {        this.mDefaultScreen = defaultScreen;    }    public void setCurScreen(int curScreen) {        mCurScreen = curScreen;    }    /*     * Touch状态值 0：静止 1：滑动     */    private static final int TOUCH_STATE_REST = 0;    private static final int TOUCH_STATE_SCROLLING = 1;    /*     * 记录当前touch事件状态--滑动（TOUCH_STATE_SCROLLING）、静止（TOUCH_STATE_REST 默认）     */    private int mTouchState = TOUCH_STATE_REST;    private static final int SNAP_VELOCITY = 300;    /*     * 记录touch事件中被认为是滑动事件前的最大可滑动距离     */    private int mTouchSlop;    /*     * 记录滑动时上次手指所处的位置     */    private float mLastMotionX;    private float mLastMotionY;    private OnScrollToScreenListener mOnScrollToScreenListener = null;    public ScreenScroller(Context context, AttributeSet attrs) {        this(context, attrs, 0);    }    public ScreenScroller(Context context, AttributeSet attrs, int defStyle) {        super(context, attrs, defStyle);        mScroller = new Scroller(context);        mCurScreen = mDefaultScreen;        mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();    }    @Override    protected void onLayout(boolean changed, int l, int t, int r, int b) {        int childLeft = 0;        final int childCount = getChildCount();        for (int i = 0; i < childCount; i++) {            final View childView = getChildAt(i);            if (childView.getVisibility() != View.GONE) {                final int childWidth = childView.getMeasuredWidth();                childView.layout(childLeft, 0, childLeft + childWidth,                        childView.getMeasuredHeight());                childLeft += childWidth;            }        }        if (mNeedToResyncScreenEdgeOnLayout == true) {            scrollTo(mCurScreen * mScreenWidth, getScrollY());            mNeedToResyncScreenEdgeOnLayout = false;        }    }    @Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        super.onMeasure(widthMeasureSpec, heightMeasureSpec);        final int count = getChildCount();        for (int i = 0; i < count; i++) {            getChildAt(i).measure(widthMeasureSpec, heightMeasureSpec);        }        int width = MeasureSpec.getSize(widthMeasureSpec);        if (mScreenWidth != width) {            mScreenWidth = width;            mNeedToResyncScreenEdgeOnLayout = true;        }    }    /**     * 方法名称：snapToDestination 方法描述：根据当前位置滑动到相应界面     *      * @param whichScreen     */    public void snapToDestination() {        final int screenWidth = mScreenWidth;        final int destScreen = (getScrollX() + screenWidth / 2) / screenWidth;        snapToScreen(destScreen, true);    }    /**     * 方法名称：snapToScreen 方法描述：滑动到到第whichScreen（从0开始）个界面，有过渡效果     *      * @param whichScreen     */    public void snapToScreen(int whichScreen, boolean shouldAnimate) {        // get the valid layout page        whichScreen = Math.max(0, Math.min(whichScreen, getChildCount() - 1));        boolean isCurrentScreen = whichScreen == mCurScreen ? true : false;        if (getScrollX() != (whichScreen * mScreenWidth)) {            final int delta = whichScreen * mScreenWidth - getScrollX();            int duration = 0;            if (shouldAnimate) {                duration = Math.min(320, (int) (Math.abs(delta) * 1.2));            }            mScroller.startScroll(getScrollX(), 0, delta, 0, duration);            mCurScreen = whichScreen;            doScrollAction(duration, isCurrentScreen);            invalidate(); // Redraw the layout        }    }    private boolean mNeedToResyncScreenEdgeOnLayout = false;    /**     * 方法名称：setToScreen 方法描述：指定并跳转到第whichScreen（从0开始）个界面     *      * @param whichScreen     */    public void setToScreen(int whichScreen) {        whichScreen = Math.max(0, Math.min(whichScreen, getChildCount() - 1));        boolean isCurrentScreen = whichScreen == mCurScreen ? true : false;        if (mScreenWidth != 0) {            // TODO: potential bug here, if view is not layed out, will not call            // doScrollAction            scrollTo(whichScreen * mScreenWidth, 0);            doScrollAction(isCurrentScreen);        } else {            mNeedToResyncScreenEdgeOnLayout = true;        }        mCurScreen = whichScreen;    }    public int getCurScreen() {        return mCurScreen;    }    @Override    public void computeScroll() {        if (mScroller.computeScrollOffset()) {            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());            postInvalidate();        }    }    boolean isScrollRightListenerCall = false;    @Override    public boolean onTouchEvent(MotionEvent event) {        if (!isScrollable) {            return super.onTouchEvent(event);        }        if (mVelocityTracker == null) {            mVelocityTracker = VelocityTracker.obtain();        }        mVelocityTracker.addMovement(event);        final int action = event.getAction();        final float x = event.getX();        switch (action) {            case MotionEvent.ACTION_DOWN:                if (!mScroller.isFinished()) {                    mScroller.abortAnimation();                }                mLastMotionX = x;                break;            case MotionEvent.ACTION_MOVE:                if (!isScrollable) {                    return false;                }                int deltaX = (int) (mLastMotionX - x);                mLastMotionX = x;                if (deltaX > 0) {                    // moving left                    if (getScrollX() >= mScreenWidth * (getChildCount() - 1)) {                        // do nothing on scroll to right edge                        scrollBy(deltaX, 0);                    } else {                        int actualMovedValue = Math.min(deltaX,                                (mScreenWidth * (getChildCount() - 1)) - getScrollX());                        scrollBy(actualMovedValue, 0);                        this.doContentScrollAction(actualMovedValue);                    }                } else {                    // moving right                    if (getScrollX() <= 0) {                        // do nothing so won't scroll over the left edge                        scrollBy(deltaX, 0);                    } else {                        int actualMovedValue = Math.min(-deltaX, getScrollX());                        scrollBy(-actualMovedValue, 0);                        this.doContentScrollAction(-actualMovedValue);                    }                }                break;            case MotionEvent.ACTION_UP:            case MotionEvent.ACTION_CANCEL:                final VelocityTracker velocityTracker = mVelocityTracker;                velocityTracker.computeCurrentVelocity(1000);                int velocityX = (int) velocityTracker.getXVelocity();                if (mCurScreen > 0 && (velocityX > SNAP_VELOCITY)) {                    // Fling enough to move left                    snapToScreen(mCurScreen - 1, true);                } else if (mCurScreen < getChildCount() - 1 && (velocityX < -SNAP_VELOCITY)) {                    // Fling enough to move right                    if (getScrollX() != 0) {                        snapToScreen(mCurScreen + 1, true);                    }                } else {                    snapToDestination();                }                if (mVelocityTracker != null) {                    mVelocityTracker.recycle();                    mVelocityTracker = null;                }                mTouchState = TOUCH_STATE_REST;                isScrollRightListenerCall = false;                break;        }        return true;    }    @Override    public boolean onInterceptTouchEvent(MotionEvent ev) {        final int action = ev.getAction();        if ((action == MotionEvent.ACTION_MOVE) && (mTouchState != TOUCH_STATE_REST)) {            return true;        }        final float x = ev.getX();        final float y = ev.getY();        switch (action) {            case MotionEvent.ACTION_DOWN:                mLastMotionX = x;                mLastMotionY = y;                System.out.println(mScroller.isFinished());                mTouchState = mScroller.isFinished() ? TOUCH_STATE_REST : TOUCH_STATE_SCROLLING;                break;            case MotionEvent.ACTION_MOVE:                if (!isScrollable) {                    return false;                }                final int xDiff = (int) Math.abs(mLastMotionX - x);                if (xDiff > mTouchSlop) {                    if (Math.abs(mLastMotionY - y) / Math.abs(mLastMotionX - x) < 1)                        mTouchState = TOUCH_STATE_SCROLLING;                }                break;            case MotionEvent.ACTION_CANCEL:            case MotionEvent.ACTION_UP:                mTouchState = TOUCH_STATE_REST;                break;        }        return mTouchState != TOUCH_STATE_REST;    }    /**     * 方法名称：doScrollAction 方法描述：当滑动切换界面时执行相应操作     *      * @param index     */    private void doScrollAction(boolean isCurrentScreen) {        this.doScrollAction(0, isCurrentScreen);    }    private void doScrollAction(int duration, boolean isCurrentScreen) {        if (mOnScrollToScreenListener != null) {            mOnScrollToScreenListener.doAction(duration, isCurrentScreen);        }    }    /**     * 方法名称：setOnScrollToScreen 方法描述：设置内部接口的实现类实例     *      * @param index     */    public void setOnScrollToScreenListener(OnScrollToScreenListener onScrollToScreenListener) {        mOnScrollToScreenListener = onScrollToScreenListener;    }    /**     * 接口名称：OnScrollToScreen 接口描述：当滑动到某个界面时可以调用该接口下的*doAction()方法执行某些操作     *      * @author wader     */    public abstract interface OnScrollToScreenListener {        public void doAction(int duration, boolean isCurrentScreen);    }    OnContentScrollListener mOnContentScrollListener;    private void doContentScrollAction(int deltaX) {        if (mOnContentScrollListener != null) {            mOnContentScrollListener.onContentScroll(-(deltaX / getChildCount()));        }    }    public void setOnContentScrollListener(OnContentScrollListener onContentScrollListener) {        mOnContentScrollListener = onContentScrollListener;    }    public abstract interface OnContentScrollListener {        public void onContentScroll(int deltaX);    }}